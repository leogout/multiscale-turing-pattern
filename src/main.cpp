#include <iostream>
#include <fstream>
#include <vector>
#include <math.h>
#include <algorithm>
#include <random>
#include <QtCore>
#include <QtWidgets>
#include <QApplication>
#include <QTextStream>
#include <QFileInfo>

#include "PaintArea.h"
#include "MainWindow.h"


unsigned int WIDTH = 1000;
unsigned int HEIGHT = 1000;
unsigned int PASSES = 10;

int circular_index(int i, int j) {
  return (WIDTH + i) % WIDTH + ((HEIGHT + j) % HEIGHT) * WIDTH;
}

void blur_h(std::vector<double> &src, std::vector<double> &dest, int r) {
  double sum;
  int area = r*2 + 1;
  for (int y = 0; y < HEIGHT; ++y) {
    sum = 0;
    for (int i = -r; i <= r; ++i) {
      sum += src[circular_index(i, y)];
    }
    for (int x = 0; x < WIDTH; ++x) {
      sum += src[circular_index(x + r, y)] - src[circular_index(x - r, y)];
      dest[circular_index(x, y)] = sum / area;
    }
  }
}

void blur_v(std::vector<double> &src, std::vector<double> &dest, int r) {
  double sum;
  int area = r*2 + 1;
  for (int x = 0; x < WIDTH; ++x) {
    sum = 0;
    for (int i = -r; i <= r; ++i) {
      sum += src[circular_index(x, i)];
    }
    for (int y = 0; y < HEIGHT; ++y) {
      sum += src[circular_index(x, y + r)] - src[circular_index(x, y - r)];
      dest[circular_index(x, y)] = sum / area;
    }
  }
}

void blur(std::vector<double> &src, std::vector<double> &dest, std::vector<double> &buffer, int r) {
  blur_h(src, buffer, r);
  blur_v(buffer, dest, r);
}

void generate(std::vector<Scale> &scales, QImage &image) {
  std::random_device rd;
  std::mt19937 mt(659485);
  std::uniform_real_distribution<double> dist(-1, 1);

  std::vector<double> main_grid(WIDTH * HEIGHT);
  std::vector<double> buffer(WIDTH * HEIGHT);
  std::vector<Color> colors(WIDTH * HEIGHT);

  for (double &i : main_grid) {
    i = dist(mt);
  }

  for (int passes = 0; passes < PASSES; ++passes) {
    std::cout << "Pass " << passes << std::endl;
    for (Scale &scale : scales) {
      blur(main_grid, scale.activator, buffer, scale.aR);
      blur(main_grid, scale.inhibitor, buffer, scale.iR);

      for (int i = 0; i < main_grid.size(); ++i) {
        scale.variation[i] = fabs(
            scale.activator[i] - scale.inhibitor[i]
        );
      }
    }

    double max = 0;
    double min = 0;

    for (int i = 0; i < main_grid.size(); ++i) {
      int best_scale = 0;
      for (int scale = 0; scale < scales.size(); scale++) {
        if (scales[scale].variation[i] < scales[best_scale].variation[i]) {
          best_scale = scale;
        }
      }

      double factor;

      if (scales[best_scale].activator[i] > scales[best_scale].inhibitor[i]) {
        factor = scales[best_scale].sa;
      } else {
        factor = -scales[best_scale].sa;
      }

      colors[i].bump_to(scales[best_scale].color, 0.1);
      main_grid[i] += factor;

      max = std::max(max, main_grid[i]);
      min = std::min(min, main_grid[i]);
    }

    // Normalization
    for (double &i : main_grid) {
      i = (i - min) / (max - min) * 2 - 1;
    }
  }

  std::ofstream output("../out/mstp.ppm", std::ios::binary);
  output << "P6" << std::endl
         << "# Generated by leogout" << std::endl
         << WIDTH << " " << HEIGHT << std::endl
         << "255" << std::endl;

  for (int i = 0; i < WIDTH; ++i) {
    for (int j = 0; j < HEIGHT; ++j) {
      Color col = colors[i + j * WIDTH] * ((main_grid[i + j * WIDTH] + 1) / 2);
      output << col;
      image.setPixel(i, j, qRgb(col.red, col.green, col.blue));
    }
  }

  output.close();
}

int main(int argc, char *argv[]) {
  QTextStream out(stdout);

  QApplication app(argc, argv);

  QWidget *window = new QWidget;
  auto main_layout = new QHBoxLayout;
  auto step_layout = new QVBoxLayout;

  std::vector<Scale> scales = {
      Scale(WIDTH*HEIGHT, 200, 50, 0.5, Color(0, 255, 255)),
      Scale(WIDTH*HEIGHT, 100, 25, 0.4, Color(255, 0, 255)),
      Scale(WIDTH*HEIGHT, 50, 10, 0.3, Color(255, 255, 0)),
      Scale(WIDTH*HEIGHT, 25, 5, 0.2, Color(0, 0, 255)),
      Scale(WIDTH*HEIGHT, 10, 2, 0.1, Color(255, 0, 0)),
  };

  auto button = new QPushButton("Render");

  for (auto &scale: scales) {
    auto mainWindow1 = new MainWindow(scale);
    step_layout->addWidget(mainWindow1);
  }

  step_layout->addWidget(button);

  QImage myImage(WIDTH, HEIGHT, QImage::Format_RGB888);
  myImage.fill(qRgb(0, 0, 0));
  auto mylabel = new QLabel;
  mylabel->setPixmap(QPixmap::fromImage(myImage));

  window->connect(button, &QPushButton::pressed, [&scales, &myImage, &mylabel]{
      generate(scales, myImage);
      mylabel->setPixmap(QPixmap::fromImage(myImage));
  });

  main_layout->addLayout(step_layout);

  main_layout->addWidget(mylabel);
  window->setLayout(main_layout);

  window->show();

  return app.exec();
}

